{"title":"js运行机制","date":"2019-03-24T16:00:00.000Z","slug":"jsOperatingMechanism","comments":true,"tags":["Js"],"categories":["学习"],"updated":"2019-05-17T05:37:48.908Z","content":"<p>&emsp;&emsp;js是单线程的语言，也就是从上到下依次执行语句的。</p>\n<h1 id=\"为什么是单线程\">为什么是单线程<a href=\"post/jsOperatingMechanism#为什么是单线程\"></a></h1><p>&emsp;&emsp;js是一种运行在浏览器中的脚本语言，若其为多线程，那么当两个线程同时操作了一个dom节点，一个删除，一个编辑，浏览器应该听哪一个或者说先执行哪一个呢？为了避免此类事情的发生，故在设计之初就将js设计为了单线程语言。</p>\n<h1 id=\"运行机制\">运行机制<a href=\"post/jsOperatingMechanism#运行机制\"></a></h1><p>&emsp;&emsp;由于js时单线程的，那么当代码在执行过程中，若部分代码执行时间过长且并不和后续代码有任何关联，那么这部分将无意义地阻塞着后续代码的执行。于是，js有了同步任务和异步任务的区分，以此来避免上述事情的发生。举例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function()&#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;,0)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(3)</span><br></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;运行的结果是： 1 3 2。其中的setTimeout就是一个异步任务，js在执行代码时，会将其放入异步任务的队列中去，当主进程空闲时，再将队列中的任务取出执行。</p>\n<h1 id=\"宏任务与微任务\">宏任务与微任务<a href=\"post/jsOperatingMechanism#宏任务与微任务\"></a></h1><blockquote>\n<p>更详细准确的一种运行机制描述。</p>\n</blockquote>\n<ul>\n<li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li>\n<li>micro-task(微任务)：Promise，process.nextTick</li>\n</ul>\n<p>&emsp;&emsp;执行时，不同地任务分配到不同地队列中，在主线程执行完毕后，会先检查执行微队列中地任务，继而执行宏队列，可以理解为微任务队列地优先级高于宏任务队列。这是一个酸爽的例子：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;1&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">    console.log(&apos;2&apos;);</span><br><span class=\"line\">    process.nextTick(function() &#123;</span><br><span class=\"line\">        console.log(&apos;3&apos;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    new Promise(function(resolve) &#123;</span><br><span class=\"line\">        console.log(&apos;4&apos;);</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(function() &#123;</span><br><span class=\"line\">        console.log(&apos;5&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">process.nextTick(function() &#123;</span><br><span class=\"line\">    console.log(&apos;6&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">new Promise(function(resolve) &#123;</span><br><span class=\"line\">    console.log(&apos;7&apos;);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function() &#123;</span><br><span class=\"line\">    console.log(&apos;8&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\">    console.log(&apos;9&apos;);</span><br><span class=\"line\">    process.nextTick(function() &#123;</span><br><span class=\"line\">        console.log(&apos;10&apos;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    new Promise(function(resolve) &#123;</span><br><span class=\"line\">        console.log(&apos;11&apos;);</span><br><span class=\"line\">        resolve();</span><br><span class=\"line\">    &#125;).then(function() &#123;</span><br><span class=\"line\">        console.log(&apos;12&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>顺序如下：</p>\n<ul>\n<li>碰到console，执行输出1</li>\n<li>碰到setTimeout，分配到宏队列</li>\n<li>碰到process.nextTick()，分配到微队列</li>\n<li>碰到Promise，执行里面的console，输出7；然后then分配到微队列</li>\n<li><p>碰到setTimeout，分配到宏队列<br>&emsp;&emsp;主线程执行完毕，进入空闲状态，先开始检查微队列（队列先进先出）,放入主进程</p>\n</li>\n<li><p>碰到process.next()，执行输出6</p>\n</li>\n<li><p>碰到then，执行输出8<br>&emsp;&emsp;接着是宏队列，两个setTimeout，将第一个放入主进程</p>\n</li>\n<li><p>碰到console，输出2</p>\n</li>\n<li>碰到process.nextTick()，分配到微队列</li>\n<li>碰到Promise，执行输出4<br>……</li>\n</ul>\n<p>最终的结果为：1 7 6 8 2 4 3 5 9 11 10 12（浏览器环境）</p>\n<blockquote>\n<p>node环境中稍有不同，1 7 6 8 2 4 9 11 3 10 5 12。</p>\n</blockquote>\n","prev":{"title":"浏览器兼容（js）","slug":"browserCompatibility-js"},"next":{"title":"http缓存机制","slug":"httpCacheMechanism"},"link":"http://github.com/post/jsOperatingMechanism/","toc":[{"title":"为什么是单线程","id":"为什么是单线程","index":"1"},{"title":"运行机制","id":"运行机制","index":"2"},{"title":"宏任务与微任务","id":"宏任务与微任务","index":"3"}]}