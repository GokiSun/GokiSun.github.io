{"title":"http历程","date":"2019-01-05T16:00:00.000Z","slug":"httpHistory","comments":true,"tags":["Internet"],"categories":["学习"],"updated":"2019-05-16T13:53:17.701Z","content":"<p>HTTP（全称：Hyper Text Transfer Protocol）:超文本传输协议。</p>\n<a id=\"more\"></a>\n<h1 id=\"HTTP-0-9\">HTTP/0.9<a href=\"post/httpHistory#HTTP-0-9\"></a></h1><blockquote>\n<p>http/0.9 =》非持续链接（一个请求处理一个事务）、GET方法</p>\n</blockquote>\n<p>  设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（URI）来标识。换句话说，早期的HTTP就是一种前端向后台索要东西（html格式的字符串）的工具，故HTTP最初的版本HTTP/0.9中，只接受GET一种请求方法，没有在通信中指定版本号，且不支持请求头。</p>\n<pre><code>http/0.9\n    + 新的格式\n    + 两种请求方法（POST、HEAD）\n    + 可控的持续连接（Connection:Keep-Alive）\n    + 丰富的内容（图像、视频、二进制文件）\n    + 状态码\n    + ……\n    = http/1.0\n</code></pre><h1 id=\"HTTP-1-0\">HTTP/1.0<a href=\"post/httpHistory#HTTP-1-0\"></a></h1><blockquote>\n<p>http/1.0 =》默认非持续链接、三种请求方法</p>\n</blockquote>\n<p>  1996年5月，HTTP/1.0 版本发布，内容大大增加。</p>\n<p>  首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p>\n<p>  其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。</p>\n<p>  再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</p>\n<p>  其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>\n<p>  另外，一个请求只能处理一个事务的情况也得到了解决办法，但需手动设置，即设置请求头Connection:Keep-Alive。</p>\n<pre><code>http/1.0\n    + 默认持续连接\n    + 五种请求方法（PUT、PATCH、HEAD、 OPTIONS、DELETE）\n    + 管道机制\n    + 分块传输编码\n    + 头部信息的Host字段\n    + ……\n    = http/1.1\n</code></pre><h1 id=\"HTTP-1-1\">HTTP/1.1<a href=\"post/httpHistory#HTTP-1-1\"></a></h1><blockquote>\n<p>http/1.1 =》默认持续连接、八种请求方法、管道机制、分块传输</p>\n</blockquote>\n<p><strong>持续连接</strong></p>\n<p>  1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p>\n<p>  1.1 版的最大变化，就是引入了持续连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</p>\n<p>  客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。</p>\n<p>  目前，对于同一个域名，大多数浏览器允许同时建立6个持续连接。</p>\n<p><strong>管道机制</strong></p>\n<p>  1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>\n<p>  举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。</p>\n<p><strong>Content-Length 字段</strong></p>\n<p>  一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。</p>\n<p>  上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。</p>\n<p>  在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p>\n<p><strong>分块传输编码</strong></p>\n<p>  使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p>\n<p>  对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer），即：将一个文件或信息分几块进行传输。</p>\n<p>  因此，1.1版规定可以不使用Content-Length字段，而使用“分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。</p>\n<p><strong>其他功能</strong></p>\n<p>  1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。</p>\n<p>  另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名，可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>\n<pre><code>http/1.1\n    + 二进制协议\n    + 多路复用\n    + 头信息压缩\n    + 服务器推送\n    + ……\n    = http/2\n</code></pre><h1 id=\"HTTP-2\">HTTP/2<a href=\"post/httpHistory#HTTP-2\"></a></h1><blockquote>\n<p>http/2 =》二进制协议、多路复用、头信息压缩、服务器推送</p>\n</blockquote>\n<p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p>\n<p><strong>二进制协议</strong></p>\n<p>  HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p>\n<p>  二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>\n<p><strong>多路复用</strong></p>\n<p>  HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>\n<p>  举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。其中涉及到了优先级的设置。</p>\n<p><strong>数据流</strong></p>\n<p>  因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>\n<p>  HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p>\n<p>  数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p>\n<p>  客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>\n<p><strong>头信息压缩</strong></p>\n<p>  HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>\n<p>  HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>\n<p><strong>服务器推送</strong></p>\n<p>  HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p>\n<p>  常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请 求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>\n","prev":{"title":"资源压缩与合并","slug":"resourceConsolidationAndCompression"},"next":{"title":"《太空旅客》","slug":"spaceTravel(movie)"},"link":"http://github.com/post/httpHistory/","toc":[{"title":"HTTP/0.9","id":"HTTP-0-9","index":"1"},{"title":"HTTP/1.0","id":"HTTP-1-0","index":"2"},{"title":"HTTP/1.1","id":"HTTP-1-1","index":"3"},{"title":"HTTP/2","id":"HTTP-2","index":"4"}]}